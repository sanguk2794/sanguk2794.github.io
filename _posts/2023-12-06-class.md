---
layout: post
title: >
  클래스 (Class)
tags: [Java]
---

# 클래스 (Class)

---
## 1. 클래스
클래스는 객체를 속성과 메서드로 정의해 놓은 설계도 혹은 틀이다. 이를 통해 서로 관계가 깊은 변수와 함수들을 함께 다룰 수 있다.

인스턴스는 클래스에 정의된 내용을 토대로 메모리에 생성된 객체를 말한다. 단, 메서드는 인스턴스에 포함되지 않는다. 메서드는 인스턴스별로 다른 상태를 가지지 않기 때문이다.
메모리에 생성된 인스턴스는 참조변수를 통해 다룰 수 있다.

### 1. 데이터와 함수의 관계
언뜻 보면 데이터와 함수는 서로 관계가 없는 것 처럼 보이지만 함수가 주로 데이터를 가지고 작업을 하기 때문에 많은 경우에 있어서 깊은 관계를 가진다.
이렇게 관련 있는 함수와 데이터를 하나의 클래스로 구성하면 보다 작업이 간단하고 명료해지며, 객체지향 언어인 자바는 데이터와 함수의 관계를 클래스를 통해 구현한다.

---
## 2. 클래스 작성
클래스의 기본 형태는 다음의 형태를 따른다.
```text
접근 제어자 + class + 클래스 이름 { 
    // 변수
    // 메서드 
}
```

예를 들어, x축과 y축을 속성으로 가지는 점을 클래스로 구현한다면 다음과 같은 클래스가 될 것이다.
```java
public class Point {
    // 값을 초기화하지 않았으므로, x와 y는 int 타입의 기본값인 0으로 초기화된다.
    int x, y;
}
```

---
## 3. 인스턴스 생성
클래스를 선언하는 것은 설계도를 작성하는 것에 불과하다. 작성한 클래스를 사용하기 위해서는 인스턴스를 생성해야 한다. 인스턴스 생성을 위해서는 `new` 연산자를 사용한다.
```java
public class Main {
    public Point getPoint() {
        // 참조변수 선언
        Point point;
        // instance 생성, 생성한 인스턴스는 참조변수를 통해서만 다루는 것이 가능하며 하나의 참조변수에 하나의 값(주소)만 저장할 수 있다.
        point = new Point();

        return point;
    }
}
```

---
## 4. 클래스의 구조
클래스는 상태를 정의하는 필드와 동작을 정의하는 메서드의 두 영역으로 나뉜다.

```java
public class Point {
    // 필드
    int x, y;

    // 메서드
    public int getX() {
        return x;
    }
}
```

---
## 5. 필드
객체의 상태를 정의한다. 클래스 내부의 변수가 이에 해당된다. 변수에는 클래스변수, 인스턴스변수, 지역변수가 존재한다.

---
## 6. 메서드
메서드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 명령어의 집합이다. 어떤 값을 파라미터로 제공하면 그 값을 이용해 작업을 수행해 결과를 반환한다.

원하는 동작을 수행하도록 작성된 메서드는 작업을 수행할 때 필요한 값만 넣으면 원하는 결과를 반환하기 때문에 내부 구현에 대해 전혀 알 필요가 없다. 
그렇기 때문에 메서드를 내부가 보이지 않는 블랙박스라고도 한다.

메서드를 작성하는 것은 많은 장점이 있다.

- 높은 재사용성 : 한 번 만들어 놓은 메서드는 몇 번이고 다시 호출할 수 있으며 다른 프로그램에서도 사용 가능하다.
- 중복된 코드의 제거 : 프로그램을 작성하다 보면 같은 내용의 문장이 반복되는 경우가 있다. 이러한 경우 중복 코드를 한 곳에 모아 관리할 수 있다.
- 프로그램의 구조화 : 문장을 작업 단위로 나눠 여러 개의 메서드로 작성함으로써 프로그램의 구조를 단순화할 수 있다. 이를 통해 프로그램의 흐름이 한 눈에 들어오도록 구현하는 것이 가능하다.

메서드는 크게 선언부와 구현부로 이루어져 있다. 메서드를 선언할 때는 선언부와 구현부를 작성해야 한다.

선언부는 반환 타입과 메서드명, 매개변수로 구성된다.
메서드의 선언 후에는 변경사항이 발생하지 않도록 신중하게 작성하는 것이 좋은데, 선언부를 변경하면 메서드가 호출되는 모든 부분의 변경이 필요하기 때문이다.

그리고, 메서드의 선언부 뒤에 오는 괄호 안의 내용을 구현부라고 하며, 메서드를 호출했을 때 수행될 동작을 구현한다.
반환값이 `void`가 아닌 경우 반드시 해당 타입과 일치하거나 자동 형변환이 가능한 값의 반환이 필요하다.
이 때, `return` 예약어를 이용해 값을 반환한다.

```java
public class Point {
    int x, y;

    // 메서드, 선언부와 구현부로 이루어져 있다.
    // 선언부 : 접근제어자, 반환값, 변수명, 파라미터로 이루어져 있다.
    public int getX() {
        // 구현부, 메서드를 호출했을 때 수항될 문장들을 넣는다.
        // return 예약어를 통해 값을 반환한다.
        return x;
    }
}
```

#### 1. 메서드의 호출
메서드를 정의하더라도 호출하지 않으면 아무 일도 일어나지 않는다. 메서드를 호출해야만 구현부의 문장이 수행된다.

메서드가 호출되면 실행중이던 메서드의 실행을 잠시 멈추고 호출된 메서드의 구현부를 실행하며, 
호출된 메서드가 작업이 끝나고 값을 반환하면 호출한 메서드의 반환값을 호출한 자리에 대입하고 실행중이던 메서드를 다시 실행한다.

#### 2. return
현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아간다. 반환 값이 존재하는 모든 메서드에서 명시적으로 값을 지정해 주어야 한다.

사실, 반환값이 없는 경우에도 `return` 예약어는 필요하다. 하지만, 컴파일러가 구현부의 마지막에 자동으로 `return;`을 추가해주므로, 명시적으로 작성하지 않아도 괜찮다.

```java
public class Point {
    int x, y;

    public void setX(int x) {
        this.x = x;

        // 컴파일러가 자동으로 아래의 코드를 추가해 준다. void이므로 반환값은 없다.
        // return;
    }
    
    public int getX() {
        // 현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아간다. 반환값이 int이므로, int 타입의 값을 반환한다.
        return x;
    }
}

public class Main {
    public static void main(String[] args) {
        Point p = new Point();
        p.setX(10);

        // p.getX() 메서드는 반환값인 10으로 치환된다. 
        System.out.println(p.getX()); // 10
    }
}

```

---
## 7. 클래스 메서드와 인스턴스 메서드
변수와 같이 메서드 앞에 `static` 예약어를 붙이면 클래스 메서드가 되며, 그렇지 않으면 인스턴스 메서드가 된다.

인스턴스 메서드는 객체를 생성한 후 `참조변수.메서드명(파라미터)`와 같은 형식으로 사용 가능하다.
인스턴스 변수와 관련된 작업에 사용하며, 클래스 멤버와 인스턴스 멤버에 모두 접근 가능하다.

클래스 메서드는 인스턴스 메서드 앞에 `static`을 붙여 선언하며, 객체를 생성하지 않고도 사용이 가능하다.
클래스 메서드는 클래스로딩 타임에 메모리에 적재되므로 클래스 메서드가 사용 가능한 시점에 인스턴스 변수가 생성되어 있는지 보장되지 않는다.

그렇기에 클래스 메서드 내부에서는 인스턴스 멤버(인스턴스 변수, 인스턴스 메서드)의 사용이 불가능하다.

### 1. 클래스 메서드 사용시의 장단점
`static`을 붙여 클래스 메서드로 선언할 경우 메서드 호출 시간이 짧아진다는 장점이 존재한다.
인스턴스 메서드의 경우 실행 시 인스턴스를 참조하는 과정이 추가적으로 필요하기 때문이다.

하지만, 클래스 메서드는 인스턴스와 구분되어 있는 전역변수와 같이 사용되기 때문에, 추론과 테스트가 까다롭고 각 객체의 데이터들이 캡슐화되어야 한다는 객체지향 프로그래밍의 원칙을 위반하고 있다는 약점 또한 존재한다.

예를 들어 코드에서 `static` 변수를 사용한다고 하면 이 변수의 상태는 코드 여러 부분에서 영향을 받을 수 있게 되고 변화를 추적하기 어려워진다.
반면에 이를 객체화하여 인스턴스로 생성하면 테스트 중에 그 변수가 어떤 상태를 가지고 있는지 추론하는 데에 보다 좁은 범위만을 확인하면 된다.

---
## 8. 매개변수와 반환타입
자바에서는 메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨준다.
기본형일 때에는 기본형 값 그대로 복사되나, 참조형의 경우에는 참조변수 내의 주소값이 전달된다.

이로 인해 기본형 변수 매개변수의 값을 호출된 메서드 내부에서 변경하더라도 호출한 메서드에서 변경되지 않으나, 참조형 변수의 내부 값은 변경된 그대로 유지되는 현상이 발생한다.

기본형 반환타입과 참조형 반환타입도 위의 기본형 매개변수, 참조형 매개변수와 다를 것 없다.
기본형 매개변수와 기본형 값을 그대로 반환하며, 참조형 매개변수는 객체의 주소값을 반환한다.

```java
public class Main {
    public void print() {
        // 기본형 매개변수는 복사본으로 원본을 변경 할 수 없다.
        int n = 10;
        System.out.println(changePrimitiveType(n));
        System.out.println(n); // 10

        // 참조형 매개변수는 복사본으로 원본의 변경이 가능하다.
        Point point = new Point();
        point.setX(2);
        point.setY(3);
        System.out.println(changeReferenceType(point));
        System.out.println(point); // x=25, y=5
    }

    private int changePrimitiveType(int n) {
        return n += 6;
    }

    private Point changeReferenceType(Point p) {
        p.setX(p.getX() + 23);
        p.setY(p.getY() + 2);
        return p;
    }
}
```

---
#### ▶ Reference
- [클래스의 개념](http://www.tcpschool.com/java/java_class_intro)
- [왜-자바에서-static의-사용을-지양해야-하는가](https://unabated.tistory.com/entry/왜-자바에서-static의-사용을-지양해야-하는가)
- 남궁성, 자바의 정석, 도우출판

---