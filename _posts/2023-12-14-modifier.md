---
layout: post
title: >
  제어자 (Modifier)
tags: [Java]
---

## 1. 제어자 (Modifier)
제어자는 클래스, 변수, 메서드의 선언부와 함께 사용되며 부가적인 의미를 부여한다.

제어자는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.

- 접근 제어자 : `public`, `protected`, `default`, `private`
- 그 외의 제어자 : `static`, `final`, `abstract`, `native`, `transient`, `synchronized`, `volatile`, `strictfp`

기본적으로 하나의 대상에 대해 여러 제어자를 선택해 사용할 수 있다. 하지만 접근 제어자는 반드시 네 가지 제어자 중 하나를 선택해 사용해야 한다.

---
## 2. 접근 제어자 (Access Modifier)
접근 제어자는 멤버 또는 클래스와 함께 사용되어 해당 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.

접근 제어자의 종류와 접근 범위는 아래와 같다.

| 접근 제어자    | 접근 범위                                     |
|-----------|-------------------------------------------|
| private   | 같은 클래스 내에서만 접근 가능하다.                      |
| default   | 같은 패키지 내에서만 접근 가능하다.                      |
| protected | 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다. |
| public    | 접근 제한이 전혀 없다.                             |

명시적으로 접근 제어자를 선언하지 않으면 `default`의 접근 제어 범위를 가진다.

```java
public class AccessModifier {
    // 접근 제한이 없다.
    public void publicMethod() { }

    // default의 접근 제어 범위를 가진다.
    // 같은 패키지 내에서만 접근이 가능하다.
    void defaultMethod() { }

    // 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
    protected void protectedMethod() { }

    // 같은 클래스 내에서만 접근이 가능하다.
    private void privateMethod() { }
}
```

사용 가능한 접근 제어자를 대상별로 정리하면 다음과 같다.

| 대상     | 접근 제어자                                   |
|--------|------------------------------------------|
| 클래스    | public, default                          |
| 메서드    | public, protected, default, private      |
| 멤버 변수  | public, protected, default, private      |
| 지역 변수  | 사용이 불가능하다. 블럭을 벗어나면 사라지므로 접근 제어가 의미가 없다. |

### 1. private
생성자에 `private` 접근 제어자를 사용하면 외부에서의 인스턴스 생성을 제한할 수 있으며, 상속이 불가능한 클래스가 된다.
그 이유는 인스턴스를 생성할 때 조상 클래스의 생성자를 호출해야 되는데, 생성자의 접근 제어자가 `private`이므로 생성자를 자손 클래스에서 호출할 수 없기 때문이다.

이런 경우에는 클래스 앞에 `final`을 추가하여 상속할 수 없는 클래스임을 알리는 것이 좋다.

---
## 3. 접근 제어자를 이용한 캡슐화 (Encapsulation)
접근 제어자를 사용하면 외부에 데이터를 감출 수 있다. 이것을 데이터 감추기(data hiding), 객체지향에서는 캡슐화라고 한다. 
접근 제어자를 통한 캡슐화는 여러 장점을 가진다.

- 데이터가 유효한 값을 유지하도록 제어할 수 있다.
- 중요 데이터를 외부에서 함부로 변경할 수 없도록 제어할 수 있다.
- 외부에서 접근할 필요가 없는 멤버들을 접근 불가능하도록 지정해 외부에 노출시키지 않음으로써 코드의 복잡성을 줄일 수 있다.

```java
// 해당 API는 주문 API의 예제이다.
// order() 메서드와 필요한 카트 데이터 정보만 알고 있으면 주문에 관한 세부 로직을 모르더라도 주문이 가능하다. 이러한 방식으로 코드의 복잡성을 줄일 수 있다.
// 그리고, 상세 메서드들의 접근 제어자를 private로 선언하고 커다란 주문 메서드 하나만을 public으로 공개하는 방법으로 예기치 않은 주문을 제어할 수 있다.
public class OrderApi {

    /**
     * 주문하기
     * */
    @ApiResponses({
            @ApiResponse(responseCode = "201", description = "Register order"),
            @ApiResponse(responseCode = "400", description = "Invalid parameter"),
            @ApiResponse(responseCode = "500", description = "Server internal error")
    })
    @RequestMapping(value="/orders", method = RequestMethod.POST)
    public ResponseEntity<?> registerOrder(@Parameter @RequestBody @Validated Cart cart) {
        if (!validate(cart)) {
            throw new BadRequestException("cart data was invalid");
        }
        saveOrder(getOrder(cart));
    }
    
    private boolean validate(Cart cart) {
        boolean result = true;
        // 처리
        return result;
    }
    
    private Order getOrder(Cart cart) {
        final Order order = new Order();
        // 처리
        return order;
    }
}

public class Cart {}
public class Order {}
```

---
## 4. 접근 제어자를 이용한 매개변수 값 유효성 검사
변수의 접근 제어자를 `private`로 설정하지 않으면, 외부에서 해당 변수를 상정되지 않은 값으로 변경할 수 있어 문제가 발생할 수 있다.
이럴 때, 변수의 접근 제어자를 `private`로 설정하고 `set(value)` 메서드에 값의 유효성 검사 로직을 추가해 두면 데이터의 무결성을 유지할 수 있다.

메서드의 사용자가 항상 옳은 값을 넘길 것이라고 가정하는 것은 위험하다. 왠만하면 유효성 검사 로직을 구현해 두는 것이 좋다.

아래 예제는 매개변수의 값이 유효한지 확인하여 잘못된 파라미터가 넘어왔을 경우 예외를 던지도록 구현했다.

```java
public class Main {
    public void setAge(int a) throws IllegalArgumentException {
        if (a < 0 || a > 200) {
            throw new IllegalArgumentException("invalid argument");
        }

        this.a = a;
    }
}
```

외부에서 멤버변수의 값을 변경하는 것을 허용하고 싶지 않을 경우에는 멤버의 접근 제어자를 `private`로 설정하고 `setter()` 메서드를 구현하지 않으면 된다.

---
## 5. 그 외의 제어자
### 1. static
`static`은 `클래스의`, `공통적인`이라는 의미를 가지며, 내부 클래스, 초기화 블럭, 메서드, 멤버 변수와 함께 사용할 수 있다.

보통 인스턴스 변수가 인스턴스별로 다른 값을 허용하는 것과 반대로 `static`이 붙은 멤버 변수와 메서드는 모든 인스턴스들이 공유한다.

| 대상      | 의미                                                                                                          |
|---------|-------------------------------------------------------------------------------------------------------------|
| 내부 클래스  | 내부 클래스는 기본적으로 외부 참조를 한다. 하지만, `static`으로 선언하면 외부 참조를 하지 않는다.                                                |
| 초기화 블럭  | 클래스가 로드될 때 단 한 번만 실행되는 초기화 블럭 선언에 사용된다.                                                                     |
| 메서드     | 인스턴스를 생성하지 않더라도 호출 가능한 클래스 메서드가 된다. 클래스 메서드에는 인스턴스 멤버를 사용할 수 없는데, 컴파일 시점에 해당 클래스 인스턴스의 존재 여부가 보장되지 않기 때문이다. |
| 멤버 변수   | 모든 인스턴스가 공유하는 클래스 변수가 된다. 클래스에 관계된 것이기에 인스턴스를 생성하지 않고 사용할 수 있다.                                             |

`static` 멤버는 아래와 같은 장점을 가진다.

- 컴파일 타임에 적재되기 때문에 인스턴스를 생성하지 않더라도 쉽게 사용이 가능하다. 
- 메서드의 경우 해당 클래스에 종속되므로 런타임 중 메서드 선택의 과정이 생략된다. 즉, 메서드 디스패치가 일어나지 않는다.
- 클래스명을 통해 호출할 때 참조변수를 통해 인스턴스를 참조하는 과정이 생략된다.

하지만, `static` 멤버는 아래와 같은 단점 또한 가진다.

- 전체 프로그램과 동일한 라이프 사이클을 가진다. 즉, 필요하지 않은 경우에도 계속 메모리 공간을 차지한다.
- 개발자가 해당 메서드의 생성과 소멸에 관여할 수 없다.
- 모든 쓰레드가 `static` 필드를 공유하기에 여러 쓰레드에서 동시에 접근하는 경우에는 동시성 문제가 발생할 수 있다.
- 오버라이딩과 직렬화가 불가능하다.
- 전역에서 접근 가능하기 때문에 인스턴스 변수에 비해 테스트가 어렵다.
- `static` 키워드가 객체지향적이지 않다는 것 또한 문제이다. 각 객체의 데이터들이 캡슐화되어야 한다는 객체지향의 원칙에 위배된다.
- 이외에도 예측이 어려운 문제가 많아진다. 하나의 가상머신에 두 카피가 올라갈 때 동일한 `static` 변수를 가지고 있는 경우가 바로 그런 경우 중 하나이다.

---
### 2. final
`final`은 `마지막의`, `변경될 수 없는`의 의미를 가지며 클래스, 메서드, 멤버 변수와 함께 사용 가능하다.

| 대상    | 의미                                          |
|-------|---------------------------------------------|
| 클래스   | 확장할 수 없는 클래스가 된다. 다른 클래스의 조상이 될 수 없다. |
| 메서드   | 재정의 불가능한 메서드가 된다. 오버라이딩이 불가능하다.             |
| 멤버 변수 | 값을 변경할 수 없는 상수가 된다.                         |

클래스를 `final` 클래스로 선언하는 이유는 상속을 막기 위해서이다.
상속은 많은 장점을 가지고 있으나 허용할 경우, 조상 클래스가 의도하지 않은 방식으로 동작하도록 수정할 수 있다는 문제가 있다.
상속받은 클래스는 외부에 공개되지 않은 조상 클래스의 멤버에 접근할 수 있기 때문에 조상 클래스의 멤버를 변경할 수 있기 때문이다.

이러한 문제를 막기 위해 `final`로 선언할 때가 많다. 예를 들어, 불변 객체로 선언된 `String` 클래스는 이를 상속받아 의도하지 않은 방식으로 동작하는 것을 제한하기 위해 `final` 클래스로 작성되었다.
만약 해당 클래스의 상속이 가능하다면 현재 사용하는 형태와 전혀 다른 형태의 `String` 클래스 또한 만들 수 있을 것이다.
하지만 이 클래스는 `String` 클래스를 조상 클래스로 가지기에 다형성에 의해 `String` 클래스 대신 사용이 가능할 것이며, 이는 `String` 클래스를 사용하고 있는 여러 패키지, 클래스, 메서드들에서 문제를 발생시킬 소지가 있다.

---
### 3. abstract
`abstract`는 `추상의`, `미완성의`의 의미를 가지고 있으며, 추상클래스와 메서드를 선언하는데 사용된다.

| 대상    | 의미                                    |
|-------|---------------------------------------|
| 클래스   | 미완성의 클래스가 된다. 미완성이므로 인스턴스의 생성이 불가능하다. |
| 메서드   | 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드가 된다.    |

추상클래스는 클래스로서의 역할을 온전하게 수행하지는 못 하지만 새로운 클래스를 작성하는데 있어서 바탕이 되는 조상 클래스로서 중요한 의미를 갖는다.
추상클래스를 상속하는 추상클래스가 아닌 클래스는 모든 추상 메서드를 정의해야 한다.

꽤 드물지만, 추상 메서드가 없는 완성된 클래스 앞에 `abstract` 키워드를 붙여 인스턴스를 생성하지 못하도록 제어하고 있는 클래스가 존재한다.
이렇게 사용하면 상속해서 사용하라는 건지 단순히 인스턴스를 생성하지 못하도록 막기 위해 사용한건지 의도가 햇갈리므로, 인스턴스 생성을 막는데에는 접근 제어자를 사용하자.

---
### 4. native
자바가 아닌 언어(보통 `C`나 `C++`)로 구현한 코드를 자바에서 사용하려고 할 때 이용된다. JNI (Java Native Interface)를 사용한다.

### 5. transient
직렬화 가능한 객체의 멤버 중 제외하고 싶은 값을 설정할 때 사용하는 제어자이다.
직렬화란 오브젝트를 데이터 스트림에 쓰기 위해 연속적인 바이트 데이터로 변환하는 것을 말한다.

### 6. synchronized
멀티 쓰레드 환경에서 두 개 이상의 쓰레드가 하나의 변수에 동시에 접근할 때 경쟁 상태가 발생하지 않도록 설정해 주는 제어자이다.
프로그램의 반응성이 떨어질 수 있다는 문제가 존재한다.

### 7. volatile
변수를 CPU 캐시가 아닌 메인 메모리에 저장할 것을 명시하기 위해 사용하는 제어자이다. 멀티 쓰레드 환경에서의 변수 값 불일치 문제를 해결할 수 있다.

### 8. strictfp
부동소수점 연산에서 엄격한 부동소수점 정책을 적용하여 연산에 대한 일관성을 보장하도록 강제하는데 사용하는 제어자이다.

---
## 6. 제어자의 조합
제어자를 조합해서 사용할 때 몇 가지 주의 사항이 있다.

- 메서드에 `static` 제어자와 `abstract` 제어자를 함께 사용할 수 없다. `static` 메서드는 클래스에 종속되기에 상속이 불가능하므로 미구현인 상태로 둘 수 없는 것이다.
- 클래스에 `abstract`, `final`을 동시에 사용할 수 없다. `final`과 `abstract`가 정반대의 의미를 가지기 때문이다.
- `abstract` 메서드의 접근 제어자가 `private`일 수 없다. `abstract` 메서드는 자손 클래스에서의 구현을 전제로 하기 때문이다.
- 메서드에 `private`, `final`을 같이 사용할 필요가 없다. `private`인 메서드는 어차피 오버라이딩이 불가능하다.

---
#### ▶ Reference
- [Static 사용을 피해야 하는 이유](https://kellis.tistory.com/127)
- [Java volatile이란?](https://nesoy.github.io/articles/2018-06/Java-volatile)
- [☕ 내부 클래스는 static 으로 선언 안하면 큰일 난다](https://inpa.tistory.com/entry/JAVA-☕-자바의-내부-클래스는-static-으로-선언하자)
- 남궁성, 자바의 정석, 도우출판

---